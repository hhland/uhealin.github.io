<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DDL语句 &mdash; ODPS 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ODPS 1.0 documentation" href="../../index.html" />
    <link rel="up" title="ODPS SQL" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="odps_sql_func.html" title="SQL内建函数"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="odps_sql_op.html" title="运算符"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">ODPS 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">ODPS SQL</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ddl">
<span id="odps-sql-ddl"></span><h1>DDL语句<a class="headerlink" href="#ddl" title="Permalink to this headline">¶</a></h1>
<div class="section" id="create-table">
<span id="odps-sql-create-table"></span><h2>创建表(CREATE TABLE)<a class="headerlink" href="#create-table" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="p">[</span><span class="n">if</span> <span class="k">not</span> <span class="k">exists</span><span class="p">]</span> <span class="k">table_name</span>
 <span class="p">[(</span><span class="n">col_name</span> <span class="n">data_type</span> <span class="p">[</span><span class="k">comment</span> <span class="n">col_comment</span><span class="p">],</span> <span class="p">...)]</span>
 <span class="p">[</span><span class="k">comment</span> <span class="n">table_comment</span><span class="p">]</span>
 <span class="p">[</span><span class="n">partitioned</span> <span class="k">by</span> <span class="p">(</span><span class="n">col_name</span> <span class="n">data_type</span> <span class="p">[</span><span class="k">comment</span> <span class="n">col_comment</span><span class="p">],</span> <span class="p">...)]</span>
 <span class="p">[</span><span class="n">lifecycle</span> <span class="n">days</span><span class="p">]</span>
 <span class="p">[</span><span class="k">as</span> <span class="n">select_statement</span><span class="p">]</span>

<span class="k">create</span> <span class="k">table</span> <span class="p">[</span><span class="n">if</span> <span class="k">not</span> <span class="k">exists</span><span class="p">]</span> <span class="k">table_name</span>
 <span class="k">like</span> <span class="n">existing_table_name</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>表名与列名均对大小写不敏感。</li>
<li>在创建表时，如果不指定if not exists选项而存在同名表，则返回出错；若指定此选项，则无论是否存在同名表，即使原表结构与要创建的目标表结构不一致，均返回成功。已存在的同名表的元信息不会被改动。</li>
<li>数据类型只能是：bigint，double，boolean，datetime及string。</li>
<li>表名，列名中不能有特殊字符，只能用英文的a-z，A-Z及数字和下划线_，且以字母开头，名称的长度不超过128字节。</li>
<li>Partitioned by 指定表的分区字段，目前仅支持string类型。分区值不可以有双字节字符(如中文)，必须是以英文字母a-z，A-Z开始后可跟字母数字，名称的长度不超过128字节。 如果名称中出现了\t，\n等特殊字符会导致分区中的数据无法读出，允许的字符包括：空格 &#8216; &#8216;，冒号&#8217;:&#8217;，下划线&#8217;_&#8217;，美元符&#8217;$&#8217;，井号&#8217;#&#8217;，点&#8217;.&#8217;，感叹号&#8217;!&#8217;和&#8217;&#64;&#8217;。当利用分区字段对表进行分区时，新增分区、更新分区内数据和读取分区数据均不需要做全表扫描，可以提高处理效率。</li>
<li>注释内容是长度不超过1024字节的有效字符串。</li>
<li>lifecycle指明此表的生命周期，create table like语句不会复制源表的生命周期属性。</li>
<li>目前，在表中建的分区层次不能超过5级。</li>
</ul>
</div></blockquote>
<p>在下面的例子中，创建表sale_detail保存销售记录，该表使用销售时间(sale_date)和销售区域(region)作为分区列：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">sale_detail</span><span class="p">(</span>
 <span class="n">shop_name</span>     <span class="n">string</span><span class="p">,</span>
 <span class="n">customer_id</span>   <span class="n">string</span><span class="p">,</span>
 <span class="n">total_price</span>   <span class="n">double</span><span class="p">)</span>
<span class="n">partitioned</span> <span class="k">by</span> <span class="p">(</span><span class="n">sale_date</span> <span class="n">string</span><span class="p">,</span><span class="n">region</span> <span class="n">string</span><span class="p">);</span>
    <span class="c1">-- 创建一张分区表sale_detail</span>
</pre></div>
</div>
<p>也可以通过create table … as select ..语句创建表，并在建表的同时将数据复制到新表中，如</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_ctas1</span> <span class="k">as</span>
   <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>此时，如果sale_detail中存在数据，上面的示例会将sale_detail的数据全部复制到sale_detail_ctas1表中。但请注意，此处sale_detail是一张分区表，而通过create table ... as select ... 语句创建的表不会复制分区属性，只会把源表的分区列作为目标表的一般列处理，即sale_detail_ctas1是一个含有5列的非分区表。</p>
<p>在create table ... as select ...语句中，如果在select子句中使用常量作为列的值，建议指定列的名字，例如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_ctas2</span> <span class="k">as</span>
   <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span>
       <span class="n">customer_id</span><span class="p">,</span>
       <span class="n">total_price</span><span class="p">,</span>
       <span class="s1">&#39;2013&#39;</span> <span class="k">as</span> <span class="n">sale_date</span><span class="p">,</span>
       <span class="s1">&#39;China&#39;</span> <span class="k">as</span> <span class="n">region</span>
   <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>如果不加列的别名，如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_ctas3</span> <span class="k">as</span>
   <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span>
       <span class="n">customer_id</span><span class="p">,</span>
       <span class="n">total_price</span><span class="p">,</span>
       <span class="s1">&#39;2013&#39;</span><span class="p">,</span>
       <span class="s1">&#39;China&#39;</span>
   <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>则创建的表sale_detail_ctas3的第四、五列会是类似&#8221;_c3&#8221;，&#8221;_c4&#8221;这样的系统自动生成的名字，再次使用表sale_detail_ctas3时需要加上反引号才能正确引用，如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">`</span><span class="n">_c3</span><span class="o">`</span><span class="p">,</span> <span class="o">`</span><span class="n">_c4</span><span class="o">`</span> <span class="k">from</span> <span class="n">sale_detail_ctas3</span><span class="p">;</span>
</pre></div>
</div>
<p>直接执行SQL &#8220;select _c3, _c4 from sale_detail_ctas3&#8221;会报错退出。因为ODPS SQL的列名不能够以&#8221;_&#8221;开头，因此必须加反引号&#8221;`&#8221;做特别处理。我们建议您使用别名，避免出现上述情况。</p>
<p>如果希望源表和目标表具有相同的表结构，可以尝试使用create table ... like操作，如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_like</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>此时，sale_detail_like的表结构与sale_detail完全相同。除生命周期属性外，列名、列注释以及表注释等均相同。但sale_detail中的数据不会被复制到sale_detail_like表中。</p>
</div>
<div class="section" id="drop-table">
<span id="odps-sql-drop-table"></span><h2>删除表(DROP TABLE)<a class="headerlink" href="#drop-table" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">drop</span> <span class="k">table</span> <span class="p">[</span><span class="n">if</span> <span class="k">exists</span><span class="p">]</span> <span class="k">table_name</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>如果不指定if exists选项而表不存在，则返回异常；若指定此选项，无论表是否存在，皆返回成功。</li>
</ul>
</div></blockquote>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_drop</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">drop</span> <span class="k">table</span> <span class="n">sale_detail_drop</span><span class="p">;</span>
    <span class="c1">--若表存在，成功返回；若不存在，异常返回；</span>

<span class="k">drop</span> <span class="k">table</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">sale_detail_drop2</span><span class="p">;</span>
    <span class="c1">--无论是否存在sale_detail_drop2表，均成功返回；</span>
</pre></div>
</div>
</div>
<div class="section" id="rename-table">
<h2>重命名表(RENAME TABLE)<a class="headerlink" href="#rename-table" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">rename</span> <span class="k">to</span> <span class="n">new_table_name</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>rename操作仅修改表的名字，不改动表中的数据。</li>
<li>如果已存在与new_table_name同名表，报错。</li>
<li>如果table_name不存在，报错。</li>
</ul>
</div></blockquote>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_rename1</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail_rename1</span> <span class="k">rename</span> <span class="k">to</span> <span class="n">sale_detail_rename2</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="create-view">
<span id="odps-sql-create-view"></span><h2>创建视图(CREATE VIEW)<a class="headerlink" href="#create-view" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="p">[</span><span class="k">or</span> <span class="k">replace</span><span class="p">]</span> <span class="k">view</span> <span class="p">[</span><span class="n">if</span> <span class="k">not</span> <span class="k">exists</span><span class="p">]</span> <span class="n">view_name</span>
 <span class="p">[(</span><span class="n">col_name</span> <span class="p">[</span><span class="k">comment</span> <span class="n">col_comment</span><span class="p">],</span> <span class="p">...)]</span>
 <span class="p">[</span><span class="k">comment</span> <span class="n">view_comment</span><span class="p">]</span>
 <span class="p">[</span><span class="k">as</span> <span class="n">select_statement</span><span class="p">]</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>创建视图时，必须有对视图所引用表的读权限。</li>
<li>视图只能包含一个有效的select语句。</li>
<li>视图可以引用其它视图，但不能引用自己，也不能循环引用。</li>
<li>不可以向视图写入数据，例如使用insert into 或者insert overwrite操作视图。</li>
<li>当视图建好以后，如果视图的引用表发生了变更，有可能导致视图无法访问，例如：删除被引用表。用户需要自己维护引用表及视图之间的对应关系。</li>
<li>如果没有指定if not exists，在视图已经存在时用create view会导致异常。这种情况可以用create or replace view来重建视图，重建后视图本身的权限保持不变。</li>
</ul>
</div></blockquote>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">view</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">sale_detail_view</span>
  <span class="p">(</span><span class="n">store_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">sale_date</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
  <span class="k">comment</span> <span class="s1">&#39;a view for table sale_detail&#39;</span>
  <span class="k">as</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="drop-view">
<h2>删除视图(DROP VIEW)<a class="headerlink" href="#drop-view" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">drop</span> <span class="k">view</span> <span class="p">[</span><span class="n">if</span> <span class="k">exists</span><span class="p">]</span> <span class="n">view_name</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>如果视图不存在且没有指定if exists，报错。</li>
</ul>
</div></blockquote>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">drop</span> <span class="k">view</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">sale_detail_view</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rename-view">
<h2>重命名视图(RENAME VIEW)<a class="headerlink" href="#rename-view" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">view</span> <span class="n">view_name</span> <span class="k">rename</span> <span class="k">to</span> <span class="n">new_view_name</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>如果已存在同名视图，报错。</li>
</ul>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">view</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">sale_detail_view</span>
  <span class="p">(</span><span class="n">store_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">sale_date</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
  <span class="k">comment</span> <span class="s1">&#39;a view for table sale_detail&#39;</span>
  <span class="k">as</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">alter</span> <span class="k">view</span> <span class="n">sale_detail_view</span> <span class="k">rename</span> <span class="k">to</span> <span class="n">market</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="add-partitions">
<span id="odps-sql-add-partition"></span><h2>添加分区(ADD PARTITIONS)<a class="headerlink" href="#add-partitions" title="Permalink to this headline">¶</a></h2>
<p>语法格式</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">add</span> <span class="p">[</span><span class="n">if</span> <span class="k">not</span> <span class="k">exists</span><span class="p">]</span> <span class="n">partition</span> <span class="n">partition_spec</span>

<span class="n">partition_spec</span><span class="p">:</span>
 <span class="p">:</span> <span class="p">(</span><span class="n">partition_col1</span> <span class="o">=</span> <span class="n">partition_col_value1</span><span class="p">,</span> <span class="n">partition_col2</span> <span class="o">=</span> <span class="n">partiton_col_value2</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>如果未指定if not exists而同名的分区已存在，则出错返回。</li>
<li>目前ODPS支持的分区数量上限为4万。</li>
<li>对于多级分区的表，如果想添加新的分区，必须指明全部的分区值。</li>
</ul>
</div></blockquote>
<p>示例：为sale_detail表添加一个新的分区，</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">add</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;201312&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">);</span>
  <span class="c1">-- 成功添加分区，用来存储2013年12月杭州地区的销售记录。</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">add</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;201312&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;shanghai&#39;</span><span class="p">);</span>
  <span class="c1">-- 成功添加分区，用来存储2013年12月上海地区的销售记录。</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">add</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">partition</span><span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;20111011&#39;</span><span class="p">);</span>
  <span class="c1">-- 仅指定一个分区sale_date，出错返回</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">add</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">partition</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="s1">&#39;shanghai&#39;</span><span class="p">);</span>
  <span class="c1">-- 仅指定一个分区region，出错返回</span>
</pre></div>
</div>
</div>
<div class="section" id="drop-partition">
<h2>删除分区(DROP PARTITION)<a class="headerlink" href="#drop-partition" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">drop</span> <span class="p">[</span><span class="n">if</span> <span class="k">exists</span><span class="p">]</span> <span class="n">partition_spec</span><span class="p">;</span>

<span class="n">partition_spec</span><span class="p">:</span>
<span class="p">:</span> <span class="p">(</span><span class="n">partition_col1</span> <span class="o">=</span> <span class="n">partition_col_value1</span><span class="p">,</span> <span class="n">partition_col2</span> <span class="o">=</span> <span class="n">partiton_col_value2</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>如果分区不存在且未指定if exists，则出错返回。</li>
</ul>
<p>示例：从表sale_detail中删除一个分区，</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">drop</span> <span class="n">partition</span><span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;201312&#39;</span><span class="p">,</span><span class="n">region</span><span class="o">=</span><span class="s1">&#39;hangzhou&#39;</span><span class="p">);</span>
 <span class="c1">-- 成功删除2013年12月杭州分区的销售。</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2>修改表的注释<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">set</span> <span class="k">comment</span> <span class="s1">&#39;tbl comment&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>table_name必须是已存在的表；comment最长1024字节；</li>
</ul>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail</span> <span class="k">set</span> <span class="k">comment</span>
   <span class="s1">&#39;new coments for table sale_detail&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>通过ODPS命令desc可以查看表中comment的修改，请参阅 <a class="reference internal" href="../odps_common.html#odps-common-desc-table-cmd"><em>查看表信息</em></a> 。</p>
</div>
<div class="section" id="id2">
<h2>添加列<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">add</span> <span class="n">columns</span> <span class="p">(</span><span class="n">col_name1</span> <span class="n">type1</span><span class="p">,</span> <span class="n">col_name2</span> <span class="n">type2</span><span class="p">...)</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>列的数据类型只能是：bigint，double，boolean，datetime及string类型。</li>
</ul>
</div>
<div class="section" id="id3">
<h2>修改列名<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="n">change</span> <span class="k">column</span> <span class="n">old_col_name</span> <span class="k">rename</span> <span class="k">to</span> <span class="n">new_col_name</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>old_col_name必须是已存在的列；</li>
<li>表中不能有名为new_col_name的列；</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id4">
<h2>修改列、分区注释<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="n">change</span> <span class="k">column</span> <span class="n">col_name</span> <span class="k">comment</span> <span class="s1">&#39;comment&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>comment内容最长1024字节；</li>
</ul>
</div>
<div class="section" id="odps-sql-lifecycle">
<span id="id5"></span><h2>修改表的生命周期属性<a class="headerlink" href="#odps-sql-lifecycle" title="Permalink to this headline">¶</a></h2>
<p>ODPS提供数据生命周期管理功能，方便用户释放存储空间，简化回收数据的流程。</p>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="k">set</span> <span class="n">lifecycle</span> <span class="n">days</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>days 参数为生命周期时间，只接受正整数。单位：天；</li>
</ul>
<p>如果表table_name是非分区表，自最后一次数据被修改开始计算，经过days天后数据仍未被改动，则此表无需用户干预，将会被ODPS自动回收(类似drop table操作)。在ODPS中，每当表的数据被修改后，表的LastDataModifiedTime将会被更新，因此，ODPS会根据每张表的LastDataModifiedTime以及lifecycle的设置来判断是否要回收此表。如果table_name是分区表，则根据各分区的LastDataModifiedTime判断该分区是否该被回收。关于LastDataModifiedTime的介绍请参考 <a class="reference internal" href="../odps_common.html#odps-common-desc-table-cmd"><em>查看表信息</em></a> 。</p>
<p>不同于非分区表，分区表的最后一个分区被回收后，该表不会被删除。生命周期只能设定到表级别，不能再分区级设置生命周期。创建表时即可指定生命周期，详情请参阅 <a class="reference internal" href="#odps-sql-create-table"><em>创建表(CREATE TABLE)</em></a> 。</p>
<p>示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">test_lifecycle</span><span class="p">(</span><span class="k">key</span> <span class="n">string</span><span class="p">)</span> <span class="n">lifecycle</span> <span class="mi">100</span><span class="p">;</span>
    <span class="c1">-- 新建test_lifecycle表，生命周期为100天。</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">test_lifecycle</span> <span class="k">set</span> <span class="n">lifecycle</span> <span class="mi">50</span><span class="p">;</span>
    <span class="c1">-- 修改test_lifecycle表，将生命周期设为50天。</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>修改表、分区的修改时间<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>ODPS SQL提供touch操作用来修改表或分区的&#8221;LastDataModifiedTime&#8221;。效果会将表或分区的&#8221;LastDataModifiedTime&#8221;修改为当前时间。</p>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">alter</span> <span class="k">table</span> <span class="k">table_name</span> <span class="n">touch</span> <span class="p">[</span><span class="n">partition</span><span class="p">(</span><span class="n">partition_col</span><span class="o">=</span><span class="s1">&#39;partition_col_value&#39;</span><span class="p">,</span> <span class="p">...)];</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>table_name或partition_col不存在，则报错返回；</li>
<li>指定的partition_col_value不存在，则报错返回；</li>
<li>此操作会改变表的&#8221;LastDataModifiedTime&#8221;的值，此时，ODPS会认为表或分区的数据有变动，生命周期的计算会重新开始。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="dml">
<span id="odps-sql-dml"></span><h1>DML语句<a class="headerlink" href="#dml" title="Permalink to this headline">¶</a></h1>
<div class="section" id="insert-overwrite-into">
<h2>更新表中的数据(INSERT OVERWRITE/INTO)<a class="headerlink" href="#insert-overwrite-into" title="Permalink to this headline">¶</a></h2>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">insert</span> <span class="n">overwrite</span><span class="o">|</span><span class="k">into</span> <span class="k">table</span> <span class="n">tablename</span> <span class="p">[</span><span class="n">partition</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)]</span>
<span class="n">select_statement</span>
<span class="k">from</span> <span class="n">from_statement</span><span class="p">;</span>
</pre></div>
</div>
<p>在ODPS SQL处理数据的过程中，insert overwrite/into用于将计算的结果保存目标表中。insert into与insert overwrite的区别是，insert into会向表或表的分区中追加数据，而insert overwrite则会在向表或分区中插入数据前清空表中的原有数据。在使用ODPS处理数据的过程中，insert overwrite/into是最常用到的语句，它们会将计算的结果保存一个表中，可以供下一步计算使用。如，可以用如下操作计算sale_detail表中不同地区的销售额</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_insert</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">alter</span> <span class="k">table</span> <span class="n">sale_detail_insert</span> <span class="k">add</span> <span class="n">partition</span><span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2013&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span><span class="p">);</span>

<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_insert</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2013&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span><span class="p">)</span>
   <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>需要注意的是，在进行insert更新数据操作时，源表与目标表的对应关系依赖于在select子句中列的顺序，而不是表与表之间列名的对应关系，下面的SQL语句仍然是合法的：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_insert</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2013&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span><span class="p">)</span>
   <span class="k">select</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">total_price</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
    <span class="c1">-- 在创建sale_detail_insert表时，列的顺序为：</span>
    <span class="c1">-- shop_name string, customer_id string, total_price bigint</span>
    <span class="c1">-- 而从sale_detail向sale_detail_insert插入数据是，sale_detail的插入顺序为：</span>
    <span class="c1">-- customer_id, shop_name, total_price</span>
    <span class="c1">-- 此时，会将sale_detail.customer_id的数据插入sale_detail_insert.shop_name</span>
    <span class="c1">-- 将sale_detail.shop_name的数据插入sale_detail_insert.customer_id</span>
</pre></div>
</div>
</div>
<div class="section" id="multi-insert">
<h2>多路输出(MULTI INSERT)<a class="headerlink" href="#multi-insert" title="Permalink to this headline">¶</a></h2>
<p>ODPS SQL支持在一个语句中插入不同的结果表或者分区</p>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">from</span> <span class="n">from_statement</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="o">|</span> <span class="k">into</span> <span class="k">table</span> <span class="n">tablename1</span> <span class="p">[</span><span class="n">partition</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)]</span>
  <span class="n">select_statement1</span>
<span class="p">[</span><span class="k">insert</span> <span class="n">overwrite</span> <span class="o">|</span> <span class="k">into</span> <span class="k">table</span> <span class="n">tablename2</span> <span class="p">[</span><span class="n">partition</span> <span class="p">...]</span>
  <span class="n">select_statement2</span><span class="p">]</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>一般情况下，单个SQL里最多可以写128路输出，超过128路报语法错误。</li>
<li>在一个multi insert中，对于分区表，同一个目标分区不可以出现多次; 对于未分区表，该表不能出现多次。</li>
<li>对于同一张分区表的不同分区，不能同时有insert overwrite和insert into操作，否则报错返回。</li>
</ul>
</div></blockquote>
<p>如，</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">from</span> <span class="n">sale_detail</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span><span class="p">;</span>
   <span class="c1">-- 成功返回，将sale_detail的数据插入到sales里的2010年及2011年中国大区的销售记录中</span>

<span class="k">from</span> <span class="n">sale_detail</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span><span class="p">;</span>
   <span class="c1">-- 出错返回，同一分区出现多次</span>

<span class="k">from</span> <span class="n">sale_detail</span>
<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span>
<span class="k">insert</span> <span class="k">into</span> <span class="k">table</span> <span class="n">sale_detail_multi</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span> <span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">total_price</span><span class="p">;</span>
   <span class="c1">-- 出错返回，同一张表的不同分区，不能同时有insert overwrite和insert into操作</span>
</pre></div>
</div>
</div>
<div class="section" id="dynamic-partition">
<span id="odps-sql-dynamic-partition"></span><h2>输出到动态分区(DYNAMIC PARTITION)<a class="headerlink" href="#dynamic-partition" title="Permalink to this headline">¶</a></h2>
<p>在insert overwrite到一张分区表时，可以在语句中指定分区的值。也可以用另外一种更加灵活的方式，在分区中指定一个分区列名，但不给出值。相应的，在select子句中的对应列来提供分区的值。</p>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">tablename</span> <span class="n">partition</span> <span class="p">(</span><span class="n">partcol1</span><span class="p">,</span> <span class="n">partcol2</span> <span class="p">...)</span>
<span class="n">select_statement</span> <span class="k">from</span> <span class="n">from_statement</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>目前，在使用动态分区功能的SQL中，在分布式环境下，单个进程最多只能输出512个动态分区，否则引发运行时异常；</li>
<li>在现阶段，任意动态分区SQL不可以生成超过2000个动态分区，否则引发运行时异常；</li>
<li>动态生成的分区值不可以为NULL，否则会引发异常；</li>
<li>如果目标表有多级分区，在运行insert语句时允许指定部分分区为静态，但是静态分区必须是高级分区；</li>
</ul>
</div></blockquote>
<p>下面，我们使用一个简单的例子来说明动态分区：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">total_revenues</span> <span class="p">(</span><span class="n">revenue</span> <span class="nb">bigint</span><span class="p">)</span>
<span class="n">partitioned</span> <span class="k">by</span> <span class="p">(</span><span class="n">region</span> <span class="n">string</span><span class="p">);</span>

<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">total_revenues</span> <span class="n">partition</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
  <span class="k">select</span> <span class="n">total_price</span> <span class="k">as</span> <span class="n">revenue</span><span class="p">,</span> <span class="n">region</span>
  <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>按照这种写法，在SQL运行之前，是不知道会产生哪些分区的，只有在select运行结束后，才能由region字段产生的值确定会产生哪些分区，这也是为什么叫做&#8221;动态分区&#8221;的原因。</p>
<p>其他示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">sale_detail_dypart</span> <span class="k">like</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_dypart</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
    <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
    <span class="c1">-- 成功返回</span>

<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sale_detail_dypart</span> <span class="n">partition</span> <span class="p">(</span><span class="n">sale_date</span><span class="o">=</span><span class="s1">&#39;2013&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span><span class="n">customer_id</span><span class="p">,</span><span class="n">total_price</span><span class="p">,</span><span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
    <span class="c1">-- 成功返回，多级分区，指定一级分区</span>

<span class="k">insert</span> <span class="n">overwrite</span> <span class="k">table</span> <span class="n">sales</span> <span class="n">partition</span> <span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="s1">&#39;china&#39;</span><span class="p">,</span> <span class="n">sale_date</span><span class="p">)</span>
    <span class="k">select</span> <span class="n">shop_name</span><span class="p">,</span><span class="n">customer_id</span><span class="p">,</span><span class="n">total_price</span><span class="p">,</span><span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
    <span class="c1">-- 失败返回，不能仅指定低级子分区，而动态插入高级分区</span>
</pre></div>
</div>
</div>
<div class="section" id="select">
<span id="odps-sql-select"></span><h2>SELECT操作<a class="headerlink" href="#select" title="Permalink to this headline">¶</a></h2>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="p">[</span><span class="k">all</span> <span class="o">|</span> <span class="k">distinct</span><span class="p">]</span> <span class="n">select_expr</span><span class="p">,</span> <span class="n">select_expr</span><span class="p">,</span> <span class="p">...</span>
 <span class="k">from</span> <span class="n">table_reference</span>
 <span class="p">[</span><span class="k">where</span> <span class="n">where_condition</span><span class="p">]</span>
 <span class="p">[</span><span class="k">group</span> <span class="k">by</span> <span class="n">col_list</span><span class="p">]</span>
 <span class="p">[</span><span class="k">order</span> <span class="k">by</span> <span class="n">order_condition</span><span class="p">]</span>
 <span class="p">[</span><span class="n">distribute</span> <span class="k">by</span> <span class="n">distribute_condition</span> <span class="p">[</span><span class="n">sort</span> <span class="k">by</span> <span class="n">sort_condition</span><span class="p">]</span> <span class="p">]</span>
 <span class="p">[</span><span class="k">limit</span> <span class="nb">number</span><span class="p">]</span>
</pre></div>
</div>
<p>在使用select语句时需要注意如下几点：</p>
<ol class="arabic simple">
<li>select操作从表中读取数据，要读的列可以用列名指定，或者用*代表所有的列，一个简单的select如下:</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>或者只读取sale_detail的一列shop_name</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">shop_name</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>在where中可以指定过滤的条件，如</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span>
<span class="k">where</span> <span class="n">shop_name</span> <span class="k">like</span> <span class="s1">&#39;hang%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请注意，当使用Select语句屏显时，目前最多只能显示1000行结果。当select作为子句时，无此限制，select子句会将全部结果返回给上层查询。</p>
</div>
<ol class="arabic simple" start="2">
<li>where子句：支持的过滤条件包括：</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">过滤条件</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&gt;, &lt;, =, &gt;=, &lt;=, &lt;&gt;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>like, rlike</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>in, not in</td>
<td>如果在in/not in条件后加子查询，子查询只能返回一列值，且返回值的数量不能超过1000。</td>
</tr>
</tbody>
</table>
<p>在select语句的where子句中可以指定分区范围，这样可以仅仅扫描表的指定部分，避免全表扫描。如下所示：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">sale_detail</span><span class="p">.</span><span class="o">*</span>
<span class="k">from</span> <span class="n">sale_detail</span>
<span class="k">where</span> <span class="n">sale_detail</span><span class="p">.</span><span class="n">sale_date</span> <span class="o">&gt;=</span> <span class="s1">&#39;2008&#39;</span> <span class="k">and</span> <span class="n">sale_detail</span><span class="p">.</span><span class="n">sale_date</span> <span class="o">&lt;=</span> <span class="s1">&#39;2014&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>ODPS SQL的where子句不支持between条件查询。</p>
<ol class="arabic simple" start="3">
<li>在table_reference中支持使用嵌套子查询，如：</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">)</span> <span class="n">t</span> <span class="k">where</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;shanghai&#39;</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>distinct：如果有重复数据行时，在字段前使用distinct，会将重复字段去重，只返回一个值，而使用all将返回字段中所有重复的值，不指定此选项时默认效果和all相同。使用distinct只返回一行记录，如</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="k">distinct</span> <span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
<span class="k">select</span> <span class="k">distinct</span> <span class="n">region</span><span class="p">,</span> <span class="n">sale_date</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
    <span class="c1">-- distinct多列，distinct的作用域是select的列集合，不是单个列。</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>group by：分组查询, 一般group by是和聚合函数配合使用。在select中包含聚合函数时，用group by指定分组的列；必须写列的完整表达式，不可用列的别名，如</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 直接使用列名作为group by的列，可以运行</span>
<span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="n">total_price</span><span class="p">)</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 以region值分组，返回每一组的销售额总量，可以运行</span>
<span class="k">select</span> <span class="n">region</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">total_price</span><span class="p">)</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 以region值分组，返回每一组的region值(组内唯一)及销售额总量，可以运行</span>

<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">r</span><span class="p">;</span>
  <span class="c1">-- 使用列的别名运行，报错返回</span>
<span class="k">select</span> <span class="s1">&#39;China-&#39;</span> <span class="o">+</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="s1">&#39;China-&#39;</span> <span class="o">+</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 必须使用列的完整表达式</span>

<span class="k">select</span> <span class="n">region</span><span class="p">,</span> <span class="n">total_price</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 报错返回，select的所有列中，没有使用聚合函数的列，必须出现在group by中</span>
<span class="k">select</span> <span class="n">region</span><span class="p">,</span> <span class="n">total_price</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">group</span> <span class="k">by</span> <span class="n">region</span><span class="p">,</span> <span class="n">total_price</span><span class="p">;</span>
  <span class="c1">-- 可以运行</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">关于聚合函数的介绍请参考 <a class="reference internal" href="odps_sql_func.html#odps-sql-aggr"><em>聚合函数</em></a></p>
</div>
<ol class="arabic simple" start="6">
<li>order by：对所有数据按照某几列进行全局排序。如果您希望按照降序对记录进行排序，可以使用DESC关键字。由于是全局排序，order by必须与limit共同使用。对在使用order by排序时，NULL会被认为比任何值都小，这个行为与Mysql一致，但是与Oracle不一致。与group by不同，order by后面必须加列的别名，当select某列时，如果没有指定列的别名，将列名作为列的别名。</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">order</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
    <span class="c1">-- 报错返回，order by没有与limit共同使用</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">order</span> <span class="k">by</span> <span class="n">region</span> <span class="k">limit</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">order</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
   <span class="c1">-- 报错返回，order by后面必须加列的别名。</span>
<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">order</span> <span class="k">by</span> <span class="n">r</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li>[limit number]的number是常数，限制输出行数。当使用无limit的select语句直接从屏幕输出查看结果时，最多只输出5000行。每个项目空间的这个屏显最大限制限制可能不同，可以通过控制台面板控制。</li>
<li>distribute by：对数据按照某几列的值做hash分片，必须使用别名。</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="n">distribute</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
   <span class="c1">-- 列名即是别名，可以运行</span>
<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="n">distribute</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
   <span class="c1">-- 报错返回，后面必须加列的别名。</span>
<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="n">distribute</span> <span class="k">by</span> <span class="n">r</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="9">
<li>sort by：局部排序，语句前必须加distribute by。实际上sort by是对distribute by的结果进行局部排序。必须使用别名。</li>
</ol>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">region</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="n">distribute</span> <span class="k">by</span> <span class="n">region</span> <span class="n">sort</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
<span class="k">select</span> <span class="n">region</span> <span class="k">as</span> <span class="n">r</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="n">sort</span> <span class="k">by</span> <span class="n">region</span><span class="p">;</span>
  <span class="c1">-- 没有distribute by，报错退出。</span>
</pre></div>
</div>
<ol class="arabic simple" start="10">
<li>order by不和distribute by/sort by共用，同时group by也不和distribute by/sort by共用;</li>
</ol>
</div>
<div class="section" id="odps-sql-subquery">
<span id="id7"></span><h2>子查询<a class="headerlink" href="#odps-sql-subquery" title="Permalink to this headline">¶</a></h2>
<p>普通的select是从几张表中读数据，如select column_1, column_2 ... from table_name，但查询的对象也可以是另外一个select操作，如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="n">shop_name</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">子查询必须要有别名。</p>
</div>
<p>在from子句中，子查询可以当作一张表来使用，与其它的表或子查询进行join操作，如</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">shop</span> <span class="k">as</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>

<span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">total_price</span> <span class="k">from</span>
 <span class="p">(</span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">shop</span><span class="p">)</span> <span class="n">a</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="o">=</span> <span class="n">sale_detail</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="union-all">
<span id="odps-sql-union-all"></span><h2>UNION ALL<a class="headerlink" href="#union-all" title="Permalink to this headline">¶</a></h2>
<p>语法格式：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="n">select_statement</span> <span class="k">union</span> <span class="k">all</span> <span class="n">select_statement</span>
</pre></div>
</div>
<p>将两个或多个select操作返回的数据集联合成一个数据集，如果结果有重复行时，会返回所有符合条件的行，不进行重复行的去重处理。需要注意的是：ODPS SQL不支持顶级的两个查询结果合并，要改写为一个子查询的形式，如</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">where</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;hangzhou&#39;</span>
  <span class="k">union</span> <span class="k">all</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">where</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;shanghai&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>需要改成：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span>
  <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">where</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;hangzhou&#39;</span>
    <span class="k">union</span> <span class="k">all</span>
  <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">sale_detail</span> <span class="k">where</span> <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;shanghai&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>union all操作对应的各个子查询的列个数、名称和类型必须一致。如果列名不一致时，可以使用列的别名加以解决。</li>
<li>一般情况下，ODPS最多允许128路union all，超过此限制报语法错误。</li>
</ul>
</div>
</div>
<div class="section" id="join">
<h2>JOIN操作<a class="headerlink" href="#join" title="Permalink to this headline">¶</a></h2>
<p>ODPS的JOIN支持多路间接，但不支持笛卡尔积，即无on条件的链接。语法定义：</p>
<div class="highlight-sql"><pre>join_table:
  table_reference join table_factor [join_condition]
| table_reference {left outer|right outer|full outer|inner} join table_reference join_condition

table_reference:
  table_factor
| join_table

table_factor:
  tbl_name [alias]
| table_subquery alias
| ( table_references )

join_condition:
  on equality_expression ( and equality_expression )*</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">equality_expression是一个等式表达式</p>
</div>
<p>left join 会从左表(shop)那里返回所有的记录，即使在右表(sale_detail)中没有匹配的行。</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">ashop</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">bshop</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">left</span> <span class="k">outer</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
  <span class="c1">-- 由于表shop及sale_detail中都有shop_name列，因此需要在select子句中使用别名进行区分。</span>
</pre></div>
</div>
<p>right outer join 右连接，返回右表中的所有记录，即使在左表中没有记录与它匹配，例如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">ashop</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">bshop</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">right</span> <span class="k">outer</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
</pre></div>
</div>
<p>full outer join 全连接，返回左右表中的所有记录，例如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">ashop</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">as</span> <span class="n">bshop</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">full</span> <span class="k">outer</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
</pre></div>
</div>
<p>在表中存在至少一个匹配时，inner join 返回行。 关键字inner可省略。</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">inner</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>

<span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
</pre></div>
</div>
<p>连接条件，只允许and连接的等值条件，并且最多支持16路join操作。只有在 <a class="reference internal" href="#odps-sql-mapjoin"><em>MAPJOIN HINT</em></a> 中，可以使用不等值连接或者使用or连接多个条件。</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">full</span> <span class="k">outer</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">shop_name</span> <span class="k">full</span> <span class="k">outer</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="k">c</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="o">=</span><span class="k">c</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
    <span class="c1">-- 支持多路join链接示例，最多支持16路join</span>

<span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
    <span class="c1">-- 不支持不等值Join链接条件，报错返回。</span>
</pre></div>
</div>
</div>
<div class="section" id="mapjoin-hint">
<span id="odps-sql-mapjoin"></span><h2>MAPJOIN HINT<a class="headerlink" href="#mapjoin-hint" title="Permalink to this headline">¶</a></h2>
<p>当一个大表和一个或多个小表做join时，可以使用mapjoin，性能比普通的join要快很多。mapjoin的基本原理是：在小数据量情况下，SQL会将用户指定的小表全部加载到执行join操作的程序的内存中，从而加快join的执行速度。需要注意，使用mapjoin时：</p>
<blockquote>
<div><ul class="simple">
<li>left outer join的左表必须是大表；</li>
<li>right outer join的右表必须是大表；</li>
<li>inner join左表或右表均可以作为大表；</li>
<li>full outer join不能使用mapjoin；</li>
<li>mapjoin支持小表为子查询；</li>
<li>使用mapjoin时需要引用小表或是子查询时，需要引用别名；</li>
<li>在mapjoin中，可以使用不等值连接或者使用or连接多个条件；</li>
<li>目前ODPS在mapjoin中最多支持指定6张小表，否则报语法错误；</li>
<li>如果使用mapjoin，则所有小表占用的内存总和不得超过512M；</li>
</ul>
</div></blockquote>
<p>下面是一个简单的示例：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="cm">/* + mapjoin(a) */</span>
 <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span><span class="p">,</span>
 <span class="n">b</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span>
 <span class="n">b</span><span class="p">.</span><span class="n">total_price</span>
<span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span>
<span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">shop_name</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">shop_name</span><span class="p">;</span>
</pre></div>
</div>
<p>ODPS SQL不支持支持在普通join的on条件中使用不等值表达式、or 逻辑等复杂的join条件，但是在mapjoin中可以进行如上操作，例如：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="cm">/*+ mapjoin(a) */</span>
 <span class="n">a</span><span class="p">.</span><span class="n">total_price</span><span class="p">,</span>
 <span class="n">b</span><span class="p">.</span><span class="n">total_price</span>
<span class="k">from</span> <span class="n">shop</span> <span class="n">a</span> <span class="k">join</span> <span class="n">sale_detail</span> <span class="n">b</span>
<span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">total_price</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">total_price</span> <span class="k">or</span> <span class="n">a</span><span class="p">.</span><span class="n">total_price</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">total_price</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="case-when">
<span id="odps-sql-case-when"></span><h2>CASE WHEN表达式<a class="headerlink" href="#case-when" title="Permalink to this headline">¶</a></h2>
<p>ODPS提供两种case when语法格式，如下所述：</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">case</span> <span class="n">value</span>
 <span class="k">when</span> <span class="p">(</span><span class="n">_condition1</span><span class="p">)</span> <span class="k">then</span> <span class="n">result1</span>
 <span class="k">when</span> <span class="p">(</span><span class="n">_condition2</span><span class="p">)</span> <span class="k">then</span> <span class="n">result2</span>
 <span class="p">...</span>
 <span class="k">else</span> <span class="n">resultn</span>
 <span class="k">end</span>

<span class="k">case</span>
  <span class="k">when</span> <span class="p">(</span><span class="n">_condition1</span><span class="p">)</span> <span class="k">then</span> <span class="n">result1</span>
  <span class="k">when</span> <span class="p">(</span><span class="n">_condition2</span><span class="p">)</span> <span class="k">then</span> <span class="n">result2</span>
  <span class="k">when</span> <span class="p">(</span><span class="n">_condition3</span><span class="p">)</span> <span class="k">then</span> <span class="n">result3</span>
  <span class="p">...</span>
  <span class="k">else</span>    <span class="n">resultn</span>
<span class="k">end</span>
</pre></div>
</div>
<p>case when表达式可以根据表达式value的计算结果灵活返回不同的值， 如以下语句根据shop_name的不同情况得出所属区域</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span>
<span class="k">case</span>
<span class="k">when</span> <span class="n">shop_name</span> <span class="k">is</span> <span class="k">null</span> <span class="k">then</span> <span class="s1">&#39;default_region&#39;</span>
<span class="k">when</span> <span class="n">shop_name</span> <span class="k">like</span> <span class="s1">&#39;hang%&#39;</span> <span class="k">then</span> <span class="s1">&#39;zj_region&#39;</span>
<span class="k">end</span> <span class="k">as</span> <span class="n">region</span>
<span class="k">from</span> <span class="n">sale_detail</span><span class="p">;</span>
</pre></div>
</div>
<p>说明：</p>
<blockquote>
<div><ul class="simple">
<li>如果result类型只有bigint，double，统一转double再返回；</li>
<li>如果result类型中有string类型，统一转string再返回，如果不能转则报错(如boolean型)；</li>
<li>除此之外不允许其它类型之间的转换；</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DDL语句</a><ul>
<li><a class="reference internal" href="#create-table">创建表(CREATE TABLE)</a></li>
<li><a class="reference internal" href="#drop-table">删除表(DROP TABLE)</a></li>
<li><a class="reference internal" href="#rename-table">重命名表(RENAME TABLE)</a></li>
<li><a class="reference internal" href="#create-view">创建视图(CREATE VIEW)</a></li>
<li><a class="reference internal" href="#drop-view">删除视图(DROP VIEW)</a></li>
<li><a class="reference internal" href="#rename-view">重命名视图(RENAME VIEW)</a></li>
<li><a class="reference internal" href="#add-partitions">添加分区(ADD PARTITIONS)</a></li>
<li><a class="reference internal" href="#drop-partition">删除分区(DROP PARTITION)</a></li>
<li><a class="reference internal" href="#id1">修改表的注释</a></li>
<li><a class="reference internal" href="#id2">添加列</a></li>
<li><a class="reference internal" href="#id3">修改列名</a></li>
<li><a class="reference internal" href="#id4">修改列、分区注释</a></li>
<li><a class="reference internal" href="#odps-sql-lifecycle">修改表的生命周期属性</a></li>
<li><a class="reference internal" href="#id6">修改表、分区的修改时间</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dml">DML语句</a><ul>
<li><a class="reference internal" href="#insert-overwrite-into">更新表中的数据(INSERT OVERWRITE/INTO)</a></li>
<li><a class="reference internal" href="#multi-insert">多路输出(MULTI INSERT)</a></li>
<li><a class="reference internal" href="#dynamic-partition">输出到动态分区(DYNAMIC PARTITION)</a></li>
<li><a class="reference internal" href="#select">SELECT操作</a></li>
<li><a class="reference internal" href="#odps-sql-subquery">子查询</a></li>
<li><a class="reference internal" href="#union-all">UNION ALL</a></li>
<li><a class="reference internal" href="#join">JOIN操作</a></li>
<li><a class="reference internal" href="#mapjoin-hint">MAPJOIN HINT</a></li>
<li><a class="reference internal" href="#case-when">CASE WHEN表达式</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="odps_sql_func.html" title="SQL内建函数"
             >next</a></li>
        <li class="right" >
          <a href="odps_sql_op.html" title="运算符"
             >previous</a> |</li>
        <li><a href="../../index.html">ODPS 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >ODPS SQL</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Alibaba 2014-07-01.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2b1.
    </div>
  <!-- 请把脚本放到 body 元素内 -->
  </body>
</html>