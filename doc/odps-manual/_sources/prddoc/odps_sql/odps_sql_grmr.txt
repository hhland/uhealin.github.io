.. _odps_sql_ddl:

DDL语句
-------------

.. _odps_sql_create_table:

创建表(CREATE TABLE)
~~~~~~~~~~~~~~~~~~~~~~~~~~

语法格式 

.. code-block:: sql

 create table [if not exists] table_name
  [(col_name data_type [comment col_comment], ...)]
  [comment table_comment]
  [partitioned by (col_name data_type [comment col_comment], ...)]
  [lifecycle days]  
  [as select_statement]

 create table [if not exists] table_name
  like existing_table_name


说明：

 * 表名与列名均对大小写不敏感。
 * 在创建表时，如果不指定if not exists选项而存在同名表，则返回出错；若指定此选项，则无论是否存在同名表，即使原表结构与要创建的目标表结构不一致，均返回成功。已存在的同名表的元信息不会被改动。
 * 数据类型只能是：bigint，double，boolean，datetime及string。
 * 表名，列名中不能有特殊字符，只能用英文的a\-z，A\-Z及数字和下划线\_，且以字母开头，名称的长度不超过128字节。
 * Partitioned by 指定表的分区字段，目前仅支持string类型。分区值不可以有双字节字符(如中文)，必须是以英文字母a-z，A-Z开始后可跟字母数字，名称的长度不超过128字节。 如果名称中出现了\\t，\\n等特殊字符会导致分区中的数据无法读出，允许的字符包括：空格 ' '，冒号':'，下划线'_'，美元符'$'，井号'#'，点'.'，感叹号'!'和'@'。当利用分区字段对表进行分区时，新增分区、更新分区内数据和读取分区数据均不需要做全表扫描，可以提高处理效率。
 * 注释内容是长度不超过1024字节的有效字符串。
 * lifecycle指明此表的生命周期，create table like语句不会复制源表的生命周期属性。
 * 目前，在表中建的分区层次不能超过5级。

在下面的例子中，创建表sale_detail保存销售记录，该表使用销售时间(sale_date)和销售区域(region)作为分区列：

.. code-block:: sql

 create table if not exists sale_detail(
  shop_name 	string,
  customer_id 	string,
  total_price 	double)
 partitioned by (sale_date string,region string);
     -- 创建一张分区表sale_detail

也可以通过create table … as select ..语句创建表，并在建表的同时将数据复制到新表中，如

.. code-block:: sql

 create table sale_detail_ctas1 as 
    select * from sale_detail;

此时，如果sale_detail中存在数据，上面的示例会将sale_detail的数据全部复制到sale_detail_ctas1表中。但请注意，此处sale_detail是一张分区表，而通过create table ... as select ... 语句创建的表不会复制分区属性，只会把源表的分区列作为目标表的一般列处理，即sale_detail_ctas1是一个含有5列的非分区表。

在create table ... as select ...语句中，如果在select子句中使用常量作为列的值，建议指定列的名字，例如：

.. code-block:: sql

 create table sale_detail_ctas2 as 
    select shop_name, 
        customer_id, 
        total_price, 
        '2013' as sale_date, 
        'China' as region 
    from sale_detail; 

如果不加列的别名，如：

.. code-block:: sql

 create table sale_detail_ctas3 as 
    select shop_name, 
        customer_id, 
        total_price, 
        '2013', 
        'China' 
    from sale_detail; 

则创建的表sale_detail_ctas3的第四、五列会是类似"_c3"，"_c4"这样的系统自动生成的名字，再次使用表sale_detail_ctas3时需要加上反引号才能正确引用，如：

.. code-block:: sql

  select `_c3`, `_c4` from sale_detail_ctas3;

直接执行SQL "select _c3, _c4 from sale_detail_ctas3"会报错退出。因为ODPS SQL的列名不能够以"_"开头，因此必须加反引号"\`"做特别处理。我们建议您使用别名，避免出现上述情况。

如果希望源表和目标表具有相同的表结构，可以尝试使用create table ... like操作，如：

.. code-block:: sql

    create table sale_detail_like like sale_detail;

此时，sale_detail_like的表结构与sale_detail完全相同。除生命周期属性外，列名、列注释以及表注释等均相同。但sale_detail中的数据不会被复制到sale_detail_like表中。

.. _odps_sql_drop_table:

删除表(DROP TABLE)
~~~~~~~~~~~~~~~~~~~~~~

语法格式

.. code-block:: sql

 drop table [if exists] table_name;

说明：

 - 如果不指定if exists选项而表不存在，则返回异常；若指定此选项，无论表是否存在，皆返回成功。

示例：

.. code-block:: sql

 
 create table sale_detail_drop like sale_detail;

 drop table sale_detail_drop;
     --若表存在，成功返回；若不存在，异常返回；        

 drop table if exists sale_detail_drop2;        
     --无论是否存在sale_detail_drop2表，均成功返回；

重命名表(RENAME TABLE)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

语法格式

.. code-block:: sql

 alter table table_name rename to new_table_name;

说明：

 - rename操作仅修改表的名字，不改动表中的数据。
 - 如果已存在与new_table_name同名表，报错。
 - 如果table_name不存在，报错。


.. code-block:: sql

 create table sale_detail_rename1 like sale_detail;

 alter table sale_detail_rename1 rename to sale_detail_rename2;

.. _odps_sql_create_view:

创建视图(CREATE VIEW)
~~~~~~~~~~~~~~~~~~~~~~~~~

语法格式

.. code-block:: sql

 create [or replace] view [if not exists] view_name
  [(col_name [comment col_comment], ...)]
  [comment view_comment]
  [as select_statement]  

说明：

  * 创建视图时，必须有对视图所引用表的读权限。
  * 视图只能包含一个有效的select语句。
  * 视图可以引用其它视图，但不能引用自己，也不能循环引用。
  * 不可以向视图写入数据，例如使用insert into 或者insert overwrite操作视图。
  * 当视图建好以后，如果视图的引用表发生了变更，有可能导致视图无法访问，例如：删除被引用表。用户需要自己维护引用表及视图之间的对应关系。
  * 如果没有指定if not exists，在视图已经存在时用create view会导致异常。这种情况可以用create or replace view来重建视图，重建后视图本身的权限保持不变。

示例：

.. code-block:: sql

 create view if not exists sale_detail_view
   (store_name, customer_id, price, sale_date, region)
   comment 'a view for table sale_detail'
   as select * from sale_detail;


删除视图(DROP VIEW)
~~~~~~~~~~~~~~~~~~~~~~~

语法格式

.. code-block:: sql

 drop view [if exists] view_name;

说明：

 - 如果视图不存在且没有指定if exists，报错。 

示例：

.. code-block:: sql

 drop view if exists sale_detail_view;

重命名视图(RENAME VIEW)
~~~~~~~~~~~~~~~~~~~~~~~~~~

语法格式

.. code-block:: sql

 alter view view_name rename to new_view_name;

说明：

- 如果已存在同名视图，报错。

示例：

.. code-block:: sql
  
 create view if not exists sale_detail_view
   (store_name, customer_id, price, sale_date, region)
   comment 'a view for table sale_detail'
   as select * from sale_detail;

 alter view sale_detail_view rename to market; 


.. _odps_sql_add_partition:

添加分区(ADD PARTITIONS)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
语法格式 

.. code-block:: sql

 alter table table_name add [if not exists] partition partition_spec 

 partition_spec:
  : (partition_col1 = partition_col_value1, partition_col2 = partiton_col_value2, ...)

说明：
 
 - 如果未指定if not exists而同名的分区已存在，则出错返回。
 - 目前ODPS支持的分区数量上限为4万。
 - 对于多级分区的表，如果想添加新的分区，必须指明全部的分区值。

示例：为sale_detail表添加一个新的分区，

.. code-block:: sql

  alter table sale_detail add if not exists partition (sale_date='201312', region='hangzhou');            
    -- 成功添加分区，用来存储2013年12月杭州地区的销售记录。

  alter table sale_detail add if not exists partition (sale_date='201312', region='shanghai');            
    -- 成功添加分区，用来存储2013年12月上海地区的销售记录。

  alter table sale_detail add if not exists partition(sale_date='20111011');                                   
    -- 仅指定一个分区sale_date，出错返回

  alter table sale_detail add if not exists partition(region='shanghai');                             
    -- 仅指定一个分区region，出错返回

删除分区(DROP PARTITION)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: sql

 alter table table_name drop [if exists] partition_spec;

 partition_spec:
 : (partition_col1 = partition_col_value1, partition_col2 = partiton_col_value2, ...)

说明：

- 如果分区不存在且未指定if exists，则出错返回。

示例：从表sale_detail中删除一个分区，

.. code-block:: sql

 alter table sale_detail drop partition(sale_date='201312',region='hangzhou');        
  -- 成功删除2013年12月杭州分区的销售。



修改表的注释
~~~~~~~~~~~~~~~~~~

.. code-block:: sql

 alter table table_name set comment 'tbl comment';

说明：

- table_name必须是已存在的表；comment最长1024字节；

示例：

.. code-block:: sql

 alter table sale_detail set comment 
    'new coments for table sale_detail';

通过ODPS命令desc可以查看表中comment的修改，请参阅 :ref:`odps_common_desc_table_cmd` 。

添加列
~~~~~~~~~~~

.. code-block:: sql

 alter table table_name add columns (col_name1 type1, col_name2 type2...)

说明：

- 列的数据类型只能是：bigint，double，boolean，datetime及string类型。

修改列名
~~~~~~~~~~~~~

.. code-block:: sql

 alter table table_name change column old_col_name rename to new_col_name;

说明：

 - old_col_name必须是已存在的列；
 - 表中不能有名为new_col_name的列；


修改列、分区注释
~~~~~~~~~~~~~~~~~

.. code-block:: sql

 alter table table_name change column col_name comment 'comment'; 

说明：

- comment内容最长1024字节；

.. _odps_sql_lifecycle:

修改表的生命周期属性
~~~~~~~~~~~~~~~~~~~~~~
ODPS提供数据生命周期管理功能，方便用户释放存储空间，简化回收数据的流程。

语法格式：

.. code-block:: sql

 alter table table_name set lifecycle days;

说明：

- days 参数为生命周期时间，只接受正整数。单位：天；

如果表table_name是非分区表，自最后一次数据被修改开始计算，经过days天后数据仍未被改动，则此表无需用户干预，将会被ODPS自动回收(类似drop table操作)。在ODPS中，每当表的数据被修改后，表的LastDataModifiedTime将会被更新，因此，ODPS会根据每张表的LastDataModifiedTime以及lifecycle的设置来判断是否要回收此表。如果table_name是分区表，则根据各分区的LastDataModifiedTime判断该分区是否该被回收。关于LastDataModifiedTime的介绍请参考 :ref:`odps_common_desc_table_cmd` 。

不同于非分区表，分区表的最后一个分区被回收后，该表不会被删除。生命周期只能设定到表级别，不能再分区级设置生命周期。创建表时即可指定生命周期，详情请参阅 :ref:`odps_sql_create_table` 。


示例：

.. code-block:: sql

  create table test_lifecycle(key string) lifecycle 100;      
      -- 新建test_lifecycle表，生命周期为100天。

  alter table test_lifecycle set lifecycle 50;                 
      -- 修改test_lifecycle表，将生命周期设为50天。


修改表、分区的修改时间
~~~~~~~~~~~~~~~~~~~~~~
ODPS SQL提供touch操作用来修改表或分区的"LastDataModifiedTime"。效果会将表或分区的"LastDataModifiedTime"修改为当前时间。

语法格式：

.. code-block:: sql

 alter table table_name touch [partition(partition_col='partition_col_value', ...)];

说明：

 - table_name或partition_col不存在，则报错返回；
 - 指定的partition_col_value不存在，则报错返回；
 - 此操作会改变表的"LastDataModifiedTime"的值，此时，ODPS会认为表或分区的数据有变动，生命周期的计算会重新开始。


.. _odps_sql_dml:

DML语句
-------------

更新表中的数据(INSERT OVERWRITE/INTO)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

语法格式：

.. code-block:: sql

 insert overwrite|into table tablename [partition (partcol1=val1, partcol2=val2 ...)] 
 select_statement
 from from_statement;

在ODPS SQL处理数据的过程中，insert overwrite/into用于将计算的结果保存目标表中。insert into与insert overwrite的区别是，insert into会向表或表的分区中追加数据，而insert overwrite则会在向表或分区中插入数据前清空表中的原有数据。在使用ODPS处理数据的过程中，insert overwrite/into是最常用到的语句，它们会将计算的结果保存一个表中，可以供下一步计算使用。如，可以用如下操作计算sale_detail表中不同地区的销售额 

.. code-block:: sql

 create table sale_detail_insert like sale_detail;

 alter table sale_detail_insert add partition(sale_date='2013', region='china');

 insert overwrite table sale_detail_insert partition (sale_date='2013', region='china') 
    select shop_name, customer_id, total_price from sale_detail;        

需要注意的是，在进行insert更新数据操作时，源表与目标表的对应关系依赖于在select子句中列的顺序，而不是表与表之间列名的对应关系，下面的SQL语句仍然是合法的：

.. code-block:: sql

 insert overwrite table sale_detail_insert partition (sale_date='2013', region='china') 
    select customer_id, shop_name, total_price from sale_detail;        
     -- 在创建sale_detail_insert表时，列的顺序为：
     -- shop_name string, customer_id string, total_price bigint
     -- 而从sale_detail向sale_detail_insert插入数据是，sale_detail的插入顺序为：
     -- customer_id, shop_name, total_price
     -- 此时，会将sale_detail.customer_id的数据插入sale_detail_insert.shop_name
     -- 将sale_detail.shop_name的数据插入sale_detail_insert.customer_id



多路输出(MULTI INSERT)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ODPS SQL支持在一个语句中插入不同的结果表或者分区

语法格式：

.. code-block:: sql

 from from_statement
 insert overwrite | into table tablename1 [partition (partcol1=val1, partcol2=val2 ...)] 
   select_statement1
 [insert overwrite | into table tablename2 [partition ...] 
   select_statement2]

说明：

 - 一般情况下，单个SQL里最多可以写128路输出，超过128路报语法错误。
 - 在一个multi insert中，对于分区表，同一个目标分区不可以出现多次; 对于未分区表，该表不能出现多次。
 - 对于同一张分区表的不同分区，不能同时有insert overwrite和insert into操作，否则报错返回。


如，

.. code-block:: sql

 create table sale_detail_multi like sale_detail;

 from sale_detail 
 insert overwrite table sale_detail_multi partition (sale_date='2010', region='china' )  
     select shop_name, customer_id, total_price 
 insert overwrite table sale_detail_multi partition (sale_date='2011', region='china' )  
     select shop_name, customer_id, total_price;              
    -- 成功返回，将sale_detail的数据插入到sales里的2010年及2011年中国大区的销售记录中
 
 from sale_detail 
 insert overwrite table sale_detail_multi partition (sale_date='2010', region='china' )  
     select shop_name, customer_id, total_price 
 insert overwrite table sale_detail_multi partition (sale_date='2010', region='china' )  
     select shop_name, customer_id, total_price;               
    -- 出错返回，同一分区出现多次
 
 from sale_detail 
 insert overwrite table sale_detail_multi partition (sale_date='2010', region='china' )  
     select shop_name, customer_id, total_price 
 insert into table sale_detail_multi partition (sale_date='2011', region='china' )  
     select shop_name, customer_id, total_price;                                    
    -- 出错返回，同一张表的不同分区，不能同时有insert overwrite和insert into操作

.. _odps_sql_dynamic_partition:

输出到动态分区(DYNAMIC PARTITION)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在insert overwrite到一张分区表时，可以在语句中指定分区的值。也可以用另外一种更加灵活的方式，在分区中指定一个分区列名，但不给出值。相应的，在select子句中的对应列来提供分区的值。

语法格式：

.. code-block:: sql

 insert overwrite table tablename partition (partcol1, partcol2 ...) 
 select_statement from from_statement;


说明：

 - 目前，在使用动态分区功能的SQL中，在分布式环境下，单个进程最多只能输出512个动态分区，否则引发运行时异常；
 - 在现阶段，任意动态分区SQL不可以生成超过2000个动态分区，否则引发运行时异常；
 - 动态生成的分区值不可以为NULL，否则会引发异常；
 - 如果目标表有多级分区，在运行insert语句时允许指定部分分区为静态，但是静态分区必须是高级分区； 

下面，我们使用一个简单的例子来说明动态分区：

.. code-block:: sql

 create table total_revenues (revenue bigint)
 partitioned by (region string);

 insert overwrite table total_revenues partition(region)
   select total_price as revenue, region
   from sale_detail;


按照这种写法，在SQL运行之前，是不知道会产生哪些分区的，只有在select运行结束后，才能由region字段产生的值确定会产生哪些分区，这也是为什么叫做"动态分区"的原因。


其他示例：

.. code-block:: sql
 
 create table sale_detail_dypart like sale_detail;

 insert overwrite table sale_detail_dypart partition (sale_date, region) 
     select * from sale_detail;              
     -- 成功返回

 insert overwrite table sale_detail_dypart partition (sale_date='2013', region) 
     select shop_name,customer_id,total_price,region from sale_detail;             
     -- 成功返回，多级分区，指定一级分区

 insert overwrite table sales partition (region='china', sale_date) 
     select shop_name,customer_id,total_price,region from sale_detail;             
     -- 失败返回，不能仅指定低级子分区，而动态插入高级分区

.. _odps_sql_select:

SELECT操作
~~~~~~~~~~~~~

语法格式：

.. code-block:: sql

  select [all | distinct] select_expr, select_expr, ...
   from table_reference
   [where where_condition]
   [group by col_list]
   [order by order_condition]
   [distribute by distribute_condition [sort by sort_condition] ] 
   [limit number]

在使用select语句时需要注意如下几点：

1. select操作从表中读取数据，要读的列可以用列名指定，或者用*代表所有的列，一个简单的select如下:

.. code-block:: sql

 select * from sale_detail;

或者只读取sale_detail的一列shop_name

.. code-block:: sql 

 select shop_name from sale_detail;

在where中可以指定过滤的条件，如

.. code-block:: sql

 select * from sale_detail
 where shop_name like 'hang%';

.. note:: 请注意，当使用Select语句屏显时，目前最多只能显示1000行结果。当select作为子句时，无此限制，select子句会将全部结果返回给上层查询。


2. where子句：支持的过滤条件包括：

+--------------------+-----------------------------------------------------------------------------------+
| 过滤条件           | 描述                                                                              |
+====================+===================================================================================+
| >, <, =, >=, <=, <>|                                                                                   |
+--------------------+-----------------------------------------------------------------------------------+
| like, rlike        |                                                                                   |
+--------------------+-----------------------------------------------------------------------------------+
| in, not in         | 如果在in/not in条件后加子查询，子查询只能返回一列值，且返回值的数量不能超过1000。 |
+--------------------+-----------------------------------------------------------------------------------+

在select语句的where子句中可以指定分区范围，这样可以仅仅扫描表的指定部分，避免全表扫描。如下所示：

.. code-block:: sql

 select sale_detail.* 
 from sale_detail
 where sale_detail.sale_date >= '2008' and sale_detail.sale_date <= '2014';

ODPS SQL的where子句不支持between条件查询。

3. 在table_reference中支持使用嵌套子查询，如：

.. code-block:: sql

 select * from (select region from sale_detail) t where region = 'shanghai';

4. distinct：如果有重复数据行时，在字段前使用distinct，会将重复字段去重，只返回一个值，而使用all将返回字段中所有重复的值，不指定此选项时默认效果和all相同。使用distinct只返回一行记录，如

.. code-block:: sql

 select distinct region from sale_detail;
 select distinct region, sale_date from sale_detail;
     -- distinct多列，distinct的作用域是select的列集合，不是单个列。

5. group by：分组查询, 一般group by是和聚合函数配合使用。在select中包含聚合函数时，用group by指定分组的列；必须写列的完整表达式，不可用列的别名，如

.. code-block:: sql

 select region from sale_detail group by region;
   -- 直接使用列名作为group by的列，可以运行
 select sum(total_price) from sale_detail group by region;
   -- 以region值分组，返回每一组的销售额总量，可以运行
 select region, sum(total_price) from sale_detail group by region;
   -- 以region值分组，返回每一组的region值(组内唯一)及销售额总量，可以运行

 select region as r from sale_detail group by r;
   -- 使用列的别名运行，报错返回
 select 'China-' + region as r from sale_detail group by 'China-' + region;
   -- 必须使用列的完整表达式 

 select region, total_price from sale_detail group by region;
   -- 报错返回，select的所有列中，没有使用聚合函数的列，必须出现在group by中
 select region, total_price from sale_detail group by region, total_price;
   -- 可以运行

.. note:: 关于聚合函数的介绍请参考 :ref:`odps_sql_aggr`

6. order by：对所有数据按照某几列进行全局排序。如果您希望按照降序对记录进行排序，可以使用DESC关键字。由于是全局排序，order by必须与limit共同使用。对在使用order by排序时，NULL会被认为比任何值都小，这个行为与Mysql一致，但是与Oracle不一致。与group by不同，order by后面必须加列的别名，当select某列时，如果没有指定列的别名，将列名作为列的别名。

.. code-block:: sql

 select * from sale_detail order by region;
     -- 报错返回，order by没有与limit共同使用
 select * from sale_detail order by region limit 100;
    
 select region as r from sale_detail order by region;
    -- 报错返回，order by后面必须加列的别名。
 select region as r from sale_detail order by r;



7. [limit number]的number是常数，限制输出行数。当使用无limit的select语句直接从屏幕输出查看结果时，最多只输出5000行。每个项目空间的这个屏显最大限制限制可能不同，可以通过控制台面板控制。

8. distribute by：对数据按照某几列的值做hash分片，必须使用别名。

.. code-block:: sql

 select region from sale_detail distribute by region;
    -- 列名即是别名，可以运行
 select region as r from sale_detail distribute by region;
    -- 报错返回，后面必须加列的别名。
 select region as r from sale_detail distribute by r;

9. sort by：局部排序，语句前必须加distribute by。实际上sort by是对distribute by的结果进行局部排序。必须使用别名。

.. code-block:: sql

 select region from sale_detail distribute by region sort by region;
 select region as r from sale_detail sort by region;
   -- 没有distribute by，报错退出。

10. order by不和distribute by/sort by共用，同时group by也不和distribute by/sort by共用;

.. _odps_sql_subquery:

子查询
~~~~~~~~~~~
普通的select是从几张表中读数据，如select column_1, column_2 ... from table_name，但查询的对象也可以是另外一个select操作，如：

.. code-block:: sql

 select * from (select shop_name from sale_detail) a;

.. note:: 子查询必须要有别名。

在from子句中，子查询可以当作一张表来使用，与其它的表或子查询进行join操作，如

.. code-block:: sql


 create table shop as select * from sale_detail;

 select a.shop_name, a.customer_id, a.total_price from 
  (select * from shop) a join sale_detail on a.shop_name = sale_detail.shop_name;

.. _odps_sql_union_all:

UNION ALL
~~~~~~~~~~~~~~

语法格式：

.. code-block:: sql

 select_statement union all select_statement


将两个或多个select操作返回的数据集联合成一个数据集，如果结果有重复行时，会返回所有符合条件的行，不进行重复行的去重处理。需要注意的是：ODPS SQL不支持顶级的两个查询结果合并，要改写为一个子查询的形式，如 


.. code-block:: sql

 select * from sale_detail where region = 'hangzhou' 
   union all 
 select * from sale_detail where region = 'shanghai';
 
需要改成：

.. code-block:: sql

 select * from (
   select * from sale_detail where region = 'hangzhou' 
     union all 
   select * from sale_detail where region = 'shanghai') 
 t;

.. note::
 * union all操作对应的各个子查询的列个数、名称和类型必须一致。如果列名不一致时，可以使用列的别名加以解决。
 * 一般情况下，ODPS最多允许128路union all，超过此限制报语法错误。


JOIN操作
~~~~~~~~~~
ODPS的JOIN支持多路间接，但不支持笛卡尔积，即无on条件的链接。语法定义：

.. code-block:: sql

  join_table:
    table_reference join table_factor [join_condition]
  | table_reference {left outer|right outer|full outer|inner} join table_reference join_condition

  table_reference:
    table_factor
  | join_table

  table_factor:
    tbl_name [alias]
  | table_subquery alias
  | ( table_references )

  join_condition:
    on equality_expression ( and equality_expression )*

.. note::  equality_expression是一个等式表达式

left join 会从左表(shop)那里返回所有的记录，即使在右表(sale_detail)中没有匹配的行。

.. code-block:: sql

 select a.shop_name as ashop, b.shop_name as bshop from shop a left outer join sale_detail b on a.shop_name=b.shop_name;
   -- 由于表shop及sale_detail中都有shop_name列，因此需要在select子句中使用别名进行区分。

right outer join 右连接，返回右表中的所有记录，即使在左表中没有记录与它匹配，例如：

.. code-block:: sql

 select a.shop_name as ashop, b.shop_name as bshop from shop a right outer join sale_detail b on a.shop_name=b.shop_name;

full outer join 全连接，返回左右表中的所有记录，例如：


.. code-block:: sql

 select a.shop_name as ashop, b.shop_name as bshop from shop a full outer join sale_detail b on a.shop_name=b.shop_name;

在表中存在至少一个匹配时，inner join 返回行。 关键字inner可省略。

.. code-block:: sql

 select a.shop_name from shop a inner join sale_detail b on a.shop_name=b.shop_name;

 select a.shop_name from shop a join sale_detail b on a.shop_name=b.shop_name;

连接条件，只允许and连接的等值条件，并且最多支持16路join操作。只有在 :ref:`odps_sql_mapjoin` 中，可以使用不等值连接或者使用or连接多个条件。

.. code-block:: sql

    select a.* from shop a full outer join sale_detail b on a.shop_name=b.shop_name full outer join sale_detail c on a.shop_name=c.shop_name;
        -- 支持多路join链接示例，最多支持16路join

    select a.* from shop a join sale_detail b on a.shop_name != b.shop_name;
        -- 不支持不等值Join链接条件，报错返回。

.. _odps_sql_mapjoin:

MAPJOIN HINT
~~~~~~~~~~~~~~~~

当一个大表和一个或多个小表做join时，可以使用mapjoin，性能比普通的join要快很多。mapjoin的基本原理是：在小数据量情况下，SQL会将用户指定的小表全部加载到执行join操作的程序的内存中，从而加快join的执行速度。需要注意，使用mapjoin时：

 - left outer join的左表必须是大表；
 - right outer join的右表必须是大表；
 - inner join左表或右表均可以作为大表；
 - full outer join不能使用mapjoin；
 - mapjoin支持小表为子查询；
 - 使用mapjoin时需要引用小表或是子查询时，需要引用别名；
 - 在mapjoin中，可以使用不等值连接或者使用or连接多个条件；
 - 目前ODPS在mapjoin中最多支持指定6张小表，否则报语法错误；
 - 如果使用mapjoin，则所有小表占用的内存总和不得超过512M；

下面是一个简单的示例：

.. code-block:: sql

 select /* + mapjoin(a) */ 
  a.shop_name, 
  b.customer_id,
  b.total_price
 from shop a join sale_detail b
 on a.shop_name = b.shop_name;


ODPS SQL不支持支持在普通join的on条件中使用不等值表达式、or 逻辑等复杂的join条件，但是在mapjoin中可以进行如上操作，例如：

.. code-block:: sql

 select /*+ mapjoin(a) */
  a.total_price,
  b.total_price
 from shop a join sale_detail b
 on a.total_price < b.total_price or a.total_price + b.total_price < 500;

.. _odps_sql_case_when:

CASE WHEN表达式
~~~~~~~~~~~~~~~~~~~~

ODPS提供两种case when语法格式，如下所述：

.. code-block:: sql

 case value
  when (_condition1) then result1
  when (_condition2) then result2
  ...
  else resultn
  end

 case
   when (_condition1) then result1
   when (_condition2) then result2
   when (_condition3) then result3
   ...
   else    resultn
 end 

case when表达式可以根据表达式value的计算结果灵活返回不同的值， 如以下语句根据shop_name的不同情况得出所属区域

.. code-block:: sql

 select 
 case 
 when shop_name is null then 'default_region'
 when shop_name like 'hang%' then 'zj_region'
 end as region
 from sale_detail;

说明：

 - 如果result类型只有bigint，double，统一转double再返回；
 - 如果result类型中有string类型，统一转string再返回，如果不能转则报错(如boolean型)；
 - 除此之外不允许其它类型之间的转换；

