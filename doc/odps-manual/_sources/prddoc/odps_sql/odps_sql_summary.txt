ODPS SQL概要
=================

简要说明
----------
ODPS SQL适用于海量数据(TB级别)，实时性要求不高的场合，它的每个作业的准备，提交等阶段要花费较长时间，因此要求每秒处理几千至数万笔事务的业务是不能用ODPS SQL完成的。

ODPS SQL采用的是类似于SQL的语法，可以看作是标准SQL的子集，但不能因此简单的把ODPS SQL等价成一个数据库，它在很多方面并不具备数据库的特征，如事务、主键约束、索引等。目前在ODPS中允许的最大SQL长度是2M。

.. note:: 如果想快速了解ODPS SQL支持的基本功能，可参考 `ODPS-SQL.pdf <resources/ODPS-SQL.pdf>`_

保留字
---------

ODPS将SQL语句的关键字作为保留字。在对表、列或是分区命名时请不要使用，否则会报错。保留字不区分大小写。下面只给出常用的保留字列表，完整的保留字列表请参阅 :ref:`odps_keyword`

+------------+-----------+-----------+------------+------------+-----------+-----------+
|          % |         & |        && |          ( |          ) |        \* |        \+ |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|         \- |         . |         / |          ; |         <  |        <= |       <>  |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|          = |        >  |        >= |          ? |        ADD |       ALL |     ALTER |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|        AND |        AS |       ASC |    BETWEEN |     BIGINT |   BOOLEAN |        BY |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|       CASE |      CAST |    COLUMN |    COMMENT |     CREATE |      DESC |  DISTINCT | 
+------------+-----------+-----------+------------+------------+-----------+-----------+
| DISTRIBUTE |   DOUBLE  |      DROP |       ELSE |      FALSE |      FROM |      FULL |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|      GROUP |        IF |        IN |     INSERT |       INTO |        IS |      JOIN |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|       LEFT | LIFECYCLE |      LIKE |      LIMIT |    MAPJOIN |       NOT |      NULL |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|         ON |        OR |     ORDER |      OUTER |  OVERWRITE | PARTITION |    RENAME |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|    REPLACE |     RIGHT |     RLIKE |     SELECT |       SORT |    STRING |     TABLE |
+------------+-----------+-----------+------------+------------+-----------+-----------+
|       THEN |     TOUCH |      TRUE |      UNION |       VIEW |      WHEN |     WHERE |
+------------+-----------+-----------+------------+------------+-----------+-----------+

.. _odps_sql_part_table:

分区表
--------

ODPS在创建表时，允许用户指定表的某些列为分区列，详情请参考 :ref:`odps_sql_create_table` 。指定分区表会对用户带来诸多便利，例如：提高SQL运行效率，减少计费等。在如下场景下使用分区表将会带来较大的收益：在select语句的where条件过滤中使用分区列作为过滤条件；与此同时，部分对分区操作的SQL的运行效率则较低，给您带来较高的计费，例如：使用 :ref:`odps_sql_dynamic_partition`  

对于部分ODPS操作命令，处理分区表和非分区表时的语法有差别，详细情况请参考 :ref:`odps_sql_ddl` 及 :ref:`odps_sql_dml` 部分的说明。

类型转换
----------------------

ODPS SQL允许数据类型之间的转换，类型转换方式包括：显式类型转换及隐式类型转换。

显式类型转换
~~~~~~~~~~~~

显式类型转换是用cast将一种数据类型的值转换为另一种类型的值的行为，在ODPS SQL中支持的显式类型转换如下：

+----------+--------+--------+--------+----------+---------+
| From To  | Bigint | Double | String | Datetime | Boolean |
+----------+--------+--------+--------+----------+---------+
| Bigint   |   --   |   Y    |   Y    |    N     |    N    |
+----------+--------+--------+--------+----------+---------+
| Double   |   Y    |   --   |   Y    |    N     |    N    |
+----------+--------+--------+--------+----------+---------+
| String   |   Y    |   Y    |   --   |    Y     |    N    |
+----------+--------+--------+--------+----------+---------+
| Datetime |   N    |   N    |   Y    |    --    |    N    |
+----------+--------+--------+--------+----------+---------+
| Boolean  |   N    |   N    |   N    |    N     |    --   |
+----------+--------+--------+--------+----------+---------+

其中，'Y'表示可以转换，'N'表示不可以转换，'--'表示不需要转换。

.. note::

  * 将double类型转为bigint类型时，小数部分会被截断，例如：cast(1.6 as bigint) = 1；
  * 满足double格式的string类型转换为bigint时，会先将string转换为double，再将double转换为bigint，因此，小数部分会被截断，例如cast("1.6" as bigint) = 1；
  * 满足bigint格式的string类型可以被转换为double类型，小数点后保留一位，例如：cast("1" as double) = 1.0；
  * 不支持的显式类型转换会导致异常；
  * 如果在执行时转换失败，报错退出；
  * 日期类型转换时采用默认格式yyyy-mm-dd hh:mi:ss，详细说明信息请参考 :ref:`odps_sql_string_2_datetime` ；
  * 部分类型之间不可以通过显式的类型转换，但可以通过SQL内建函数进行转换，例如：从boolean类型转换到string类型，可使用函数to_char，详细介绍请参考 :ref:`odps_sql_function_datetime_to_char` ，而to_date函数同样支持从string类型到datetime类型的转换，详细介绍请参考 :ref:`odps_sql_function_datetime_to_date` ；
  * 关于cast的介绍请参阅 :ref:`odps_sql_function_cast` ；

隐式类型转换
~~~~~~~~~~~~

隐式类型转换是指在运行时，由ODPS依据上下文使用环境及类型转换规则自动进行的类型转换。ODPS支持的隐式类型转换规则与显式转换相同：

+----------+--------+--------+--------+----------+---------+
| From  To | Bigint | Double | String | Datetime | Boolean |
+----------+--------+--------+--------+----------+---------+
| Bigint   |   --   |   Y    |   Y    |    N     |    N    |
+----------+--------+--------+--------+----------+---------+
| Double   |   Y    |   --   |   Y    |    N     |    N    |
+----------+--------+--------+--------+----------+---------+
| String   |   Y    |   Y    |   --   |    Y     |    N    |
+----------+--------+--------+--------+----------+---------+
| Datetime |   N    |   N    |   Y    |    --    |    N    |
+----------+--------+--------+--------+----------+---------+
| Boolean  |   N    |   N    |   N    |    N     |    --   |
+----------+--------+--------+--------+----------+---------+

其中，'Y'表示可以转换，'N'表示不可以转换，'--'表示不需要转换。

.. note::

 * 不支持的隐式类型转换会导致异常；
 * 如果在执行时转换失败，也会导致异常；
 * 由于隐式类型转换是ODPS依据上下文使用环境自动进行的类型转换，因此，我们推荐在类型不匹配时显式的用cast进行转换;
 * 隐式类型转换规则是有发生作用域的。在某些作用域中，只有一部分规则可以生效。详细信息请参考 :ref:`odps_sql_cast_domain` ；

.. _odps_sql_cast_domain:

隐式类型转换的作用域
~~~~~~~~~~~~~~~~~~~~

关系运算符(=, <>, <, <=, >, >=, IS NULL, IS NOT NULL)
.......................................................


关系运算符包括=, <>, <, <=, >, >=, IS NULL, IS NOT NULL, LIKE, RLIKE和IN。由于LIKE, RLIKE和IN的隐式类型转换规则不同于其他关系运算符，将单独拿出章节对这三种关系运算符做出说明。本小节的说明不包含这三种特殊的关系运算符。当不同类型的数据共同参与关系运算时，按照下述原则进行隐式类型转换。

+----------+--------+--------+----------+----------+---------+
| From  To | Bigint | Double | String   | Datetime | Boolean |
+----------+--------+--------+----------+----------+---------+
| Bigint   |   --   | Double | Double   |    N     |    N    |
+----------+--------+--------+----------+----------+---------+
| Double   | Double |   --   | Double   |    N     |    N    |
+----------+--------+--------+----------+----------+---------+
| String   | Double | Double |   --     | Datetime |    N    |
+----------+--------+--------+----------+----------+---------+
| Datetime |   N    |   N    | Datetime |    --    |    N    |
+----------+--------+--------+----------+----------+---------+
| Boolean  |   N    |   N    |   N      |    N     |    --   |
+----------+--------+--------+----------+----------+---------+

.. note:: 

 - 如果待比较的两个类型间不能进行隐式类型转换，则该关系运算不能完成，报错退出；
 - 关系运算符介绍，请参阅 :ref:`odps_sql_rel_op` ；

特殊的关系运算符(LIKE, RLIKE, IN)
.................................

LIKE及RLIKE的使用方式形如：

.. code-block:: sql

 source like pattern;
 source rlike pattern;

此二者在隐式类型转换中的注意事项：

1. LIKE和RLIKE的source和pattern参数均仅接受string类型；

2. 其他类型不允许参与运算，也不能进行到string类型的隐式类型转换；

IN的使用方式形如：

.. code-block:: sql

 key in (value1, value2, …)

In的隐式转换规则：

1. In右侧的value值列表中的数据类型必须一致；

2. 当key与values之间比较时，若bigint, double, string之间比较，统一转double，若datetime和string之间比较，统一转datetime。除此之外不允许其它类型之间的转换。

算术运算符
..........

算术运算符包括：+, -, * , /, %, +, -，其隐式转换规则：

1. 只有string、bigint和double才能参与算术运算。String在参与运算前会进行隐式类型转换到double。Bigint和double共同参与计算时，会将bigint隐式转换为double。

2. 日期型和布尔型不允许参与算数运算。

.. note:: 算术运算符的相关章节 :ref:`odps_sql_arith_op`

位运算符
.........

位运算符包括：&和|, 其隐式转换规则：

1. 只有bigint才能参与位运算。

2. 其他类型不允许参与位运算，也不允许其他类型的隐式类型转换。

.. note:: 位运算符的相关章节 :ref:`odps_sql_bit_op`

逻辑运算符
..........

逻辑运算符包括：and, or和not，其隐式转换规则:

1. 只有boolean才能参与逻辑运算。

2. 其他类型不允许参与逻辑运算，也不允许其他类型的隐式类型转换。

.. note:: 逻辑运算符的相关章节 :ref:`odps_sql_logic_op`

ODPS SQL内建函数
........................

ODPS SQL提供了大量的系统函数，方便用户对任意行的一列或多列进行计算，输出任意种的数据类型。其隐式转换规则:

1. 在调用函数时，如果输入参数的数据类型与函数定义的参数数据类型不一致，把输入参数的数据类型转换为函数定义的数据类型。

2. 每个ODPS SQL内建函数的参数对于允许的隐式类型转换的要求不同，详见 :ref:`odps_sql_function` 部分的说明。

CASE WHEN
..........

Case when的隐式转换规则:

1. 如果返回类型只有bigint,double，统一转double；

2. 如果返回类型中有string类型，统一转string，如果不能转则报错(如boolean类型)；

3. 除此之外不允许其它类型之间的转换；

.. note:: Case when的详细介绍请参阅 :ref:`odps_sql_case_when`

分区列
.......

ODPS SQL支持分区表，对于分区表的定义，请参考 :ref:`odps_sql_ddl` 及 :ref:`odps_sql_dml` 部分的说明 。目前，ODPS分区仅支持string类型，不支持其他任意类型的隐式类型转换。

UNION ALL
..........

参与 :ref:`odps_sql_union_all` 运算的所有列的数据类型、列个数、列名称必须完全一致，否则抛异常。


.. _odps_sql_string_2_datetime:

String类型与Datetime类型之间的转换
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ODPS支持string类型和datetime类型之间的相互转换。转换时使用的格式为yyyy-mm-dd hh:mi:ss，其中：

+------+--------------------+------------------+
| 单位 | 字符串(忽略大小写) | 有效值域         |
+------+--------------------+------------------+
| 年   | yyyy               | 0001 ~ 9999      |
+------+--------------------+------------------+
| 月   | mm                 | 01 ~ 12          |
+------+--------------------+------------------+
| 日   | dd                 | 01 ~ 28,29,30,31 |
+------+--------------------+------------------+
| 时   | hh                 | 00 ~ 23          |
+------+--------------------+------------------+
| 分   | mi                 | 00 ~ 59          |
+------+--------------------+------------------+
| 秒   | ss                 | 00 ~ 59          |
+------+--------------------+------------------+

.. note:: 各个单位的值域中，如果首位为0，不可省略，例如："2014-1-9 12:12:12"就是非法的datetime格式，无法从这个string类型数据转换为datetime类型，必须写为"2014-01-09 12:12:12"。

只有符合上述格式描述的string类型才能够转换为datetime类型，例如：cast("2013-12-31 02:34:34" as datetime)将会把string类型"2013-12-31 02:34:34"转换为datetime类型。同理，datetime转换为string时，默认转换为yyyy-mm-dd hh:mi:ss的格式。类似于下面的转换尝试，将会失败导致异常，例如：

.. code-block:: sql

 cast("2013/12/31 02/34/34" as datetime)
 cast("20131231023434" as datetime)
 cast("2013-12-31 2:34:34" as datetime)

值得注意的是，"dd"部分的阈值上限取决于月份实际拥有的天数，如果超出对应月份实际拥有的天数，将会导致异常退出，例如：

.. code-block:: sql

 cast("2013-02-29 12:12:12" as datetime)      -- 异常返回，2013年2月没有29日
 cast("2013-11-31 12:12:12" as datetime)      -- 异常返回，2013年11月没有31日

ODPS提供了to_date函数，用以将不满足日期格式的string类型数据转换为datetime类型。详细信息请参阅 :ref:`odps_sql_function_datetime_to_date` 。
